트랜잭션, DB 락
==
데이터베이스에 데이터를 저장하는 가장 큰 이유는 **트랜잭션**을 지원하기 때문이다.

**트랜잭션**은 하나의 거래를 안전하게 처리하도록 보장하는 것이다. 
- 여러개의 쿼리가 하나의 트랜잭션이라면, 모든 쿼리들이 정상적으로 처리되야 한다.
- 모든 작업이 성공해서 데이터베이스에 정상 반영하는 것을 **커밋**이라 하고, 하나라도 실패해서 이전 상태로 되돌리는 것을 **롤백**이라고 한다.


## 트랜잭션 ACID
트랜잭션은 ACID라는 원자성(Atomicity), 일관성(Consistency), 격리성(Isolation), 지속성(Duration)을 보장해야한다.

- **원자성:** 트랜잭션 내에서 실행한 작업은 마치 하나의 작업인 것처럼 모두 성공하거나, 실패해야한다. All Or Nothing
- **일관성:** 모든 트랜잭션은 일관성 있는 데이터베이스 상태를 유지해야 한다.
- **격리성:** 동시에 실행되는 트랜잭션들이 서로에게 영향을 미치지 않도록 격리한다. 동시성 관련 문제로 인해, 격리 수준을 선택할 수 있다.
- **지속성:** 트랜잭션을 성공적으로 끝내면 그 결과가 항상 기록되어야 한다. 중간에 시스템에 문제가 발생해도 로그를 통해 성공한 트랜잭션 내용을 복구 해야한다.


## 트랜잭션 이해
애플리케이션에서 커넥션을 획득하면 데이터베이스 서버 내부에는 **세션**이 만들어진다. 

#### 트랜잭션 사용
여기서는 세션 1이 테이블에 데이터를 삽입하고 세션 2가 이를 조회하는 경우를 생각해보자.
- 데이터 변경 쿼리를 실행하고 그 결과를 데이터베이스에 반영하려면 `commit` 명령어를 호출하고, 이전 상태로 되돌리고 싶으면 `rollback`을 사용한다
- 커밋 이전에는 임시적으로 데이터를 저장해 트랜잭션을 수행한 세션에서만 변경된 데이터가 보이고 다른 세션에서는 보이지 않는다.
- 세션 1에서 변경 쿼리를 실행시키고 `commit`하지 않은 상태에서 세션 2에서 select 를 수행하면 데이터가 보이지 않는다.

**세션 1 신규 데이터를 추가한 후 commit**
- 커밋을 하게되면 세션 2 뿐아닌 모든 세션에서 세션 1에서 진행한 트랜잭션의 결과를 조회할 수 있게 된다.

**세션 1 신규 데이터를 추가한 후 rollback**
- 세션 1에서 임시로 저장한 데이터를 이전 상태로 되돌리고, 다른 세션들은 이전 처럼 정상적으로 조회가 가능하다.


#### 자동 커밋, 수동 커밋

데이터베이스는 **자동 커밋**모드를 기본적으로 사용하고 있다. 자동 커밋모드는 등록, 수정, 삭제 쿼리를 호출하면 그 즉시 커밋이 되는 데이터베이스 모드이다.

**수동 커밋**모드는 `commit`, `rollback` 명령어를 통해 변경사항을 저장하고 되돌릴 수 있는 데이터베이스 모드이다. 수동 커밋모드를 활성화했을 때, 트랜잭션을 시작했다고 한다.
- 트랜잭션 내 작업이 하나라도 실패하면, `rollback`, 전부 성공하면 데이터를 반영하는 `commit`을 호출해서 원자성을 지켜야한다.


## DB 락
세션1이 트랜잭션을 시작하고 수정하는 동안 커밋하지 않은 데이터를 다른 세션이 동시에 수정한다면 심각한 문제가 발생한다.
- 원자성이 깨지고, 잘못된 데이터를 수정하는 문제가 동시에 발생

이런 문제가 발생하지 않기 위해 커밋이나, 롤백 전까지는 다른 세션이 데이터에 접근할 수 없도록 막아야한다. 이를 위해 DB에서는 **락**을 제공한다.

#### 락 동작 - 삭제, 등록, 업데이트
세션 1, 세션 2가 동시에 특정한 row를 수정하는 상황이라고 가정한다면 다음과 같이 동작한다.
- 세션 1이 먼저 해당 row를 수정하기 위해 트랜잭션을 수행하면, 그 row들의 락을 획득한다.
- 세션 2가 트랜잭션을 수행하려고 보니, 락이 존재하지 않기 때문에 대기한다.
- 세션 1이 commit을 하면 락이 반환되고 동시에, 대기하고 있던 세션 2에서 lock을 획득해 트랜잭션을 수행한다.
- 세션 2에서 Lock 을 획득하지 못하면 timeout이 발생해 오류가 발생한다.


#### 락 동작 - 조회
조회를 할 때, 다른 세션에서 업데이트를 하면 안되는 경우 락을 걸고 조회를 할 수 있다.
- select for update 문을 사용하면 락을 걸고 조회를 할 수있다.
- 중요한 어플리케이션 로직이 처리되야할 경우 이를 사용한다.



#### 트랜잭션 - 코드 적용
코드로 트랜잭션을 적용하기 위해선, 수동 커밋모드로 변경시키고 비즈니스 로직을 전부 실행한 후 커밋이나 롤백을 수행해야한다.

서비스 계층으로 트랜잭션 코드가 있어 매우 복잡한 코드가 요구되는데, 스프링이 해당 문제를 해결해준다.

#### 트랜잭션 코드의 문제점
애플리케이션 구조
- 가장 단순하고 많이 사용하는 방법은 프레젠테이션 계층, 서비스 계층, 데이터 접근 계층을 나눠 개발하는 것이 가장 단순하다.

- **프레젠테이션 계층**
  - UI와 관련된 처리 기술
  - 웹 요청과 응답
  - 사용자 요청을 검증
  - 서블릿, HTTP 같은 웹기술, 스프링 MVC

- **서비스 계층**
  - 비즈니스 로직을 담당
  - 순수 자바 코드로 작성
- **데이터 접근 계층**
  - 실제 데이터베이스에 접근하는 코드
  - JDBC, JPA, Redis, File, Mongo

3가지 계층 중 가장 중요한 계층은 서비스 계층이다. 그래서 순수한 서비스 계층을 유지하는 것이 중요하다.

서비스 계층을 특정 기술에 종속적이지 않게 개발하면 다음과 같은 장점을 가진다.
- 프레젠테이션 계층, 데이터 접근 계층의 기술이 변경되도 핵심 비즈니스 코드에는 영향을 미치지 않는다.
- 핵심 로직을 테스트하고, 유지보수하기가 쉬워진다.

현재 모든 서비스 계층에서 데이터 접근 기술에 의존하고 있다.
- ex) SQLException, 트랜잭션 관련 코드

**정리**
- 트랜잭션 코드
  - 서비스 계층은 순수한 자바코드로 구성돼 있어야 하나, 그렇지 못한 문제
    - 비즈니스 로직은 순수해야 한다. 그래서 데이터 접근 계층에 JDBC 코드를 몰아둔 것이다.
    - 하지만, 트랜잭션을 수행하기 위해 서비스 계층에서 데이터 접근 기술을 사용해야한다.
  - 같은 커넥션을 유지하기 위해 커넥션을 계속 파라미터를 통해 넘겨야한다.
  - 트랜잭션 예외 처리가 반복적이다.
  
- 예외 누수
  - SQLException이 체크 예외이기 때문에 데이터 접근 계층을 호출한 서비스 계층에서 예외를 처리하거나 명시적으로 다시 밖으로 던져야한다.  
- JDBC 반복 문제
  - 유사한 코드들이 지속적으로 반복된다.
  - try, catch, finally..


#### 트랜잭션 추상화
트랜잭션 코드를 추상화해서 인터페이스로 제공하면 구현 기술이 달라져도 DI를 통해 OCP 원칙을 지킬 수 있다.

스프링에서 `PlatformTransactionManager`라는 인터페이스를 제공하고 각 기술들이 인터페이스를 구현하고 있어 가져다 쓰면 된다.

#### 트랜잭션 동기화
스프링의 트랜잭션 매니저는 2가지 역할을 한다.
- 트랜잭션 추상화
- 리소스 동기화
  - 트랜잭션을 유지하려면 커넥션을 유지해야한다. 
    - 트랜잭션 매니저는 트랜잭션 동기화 매니저를 활용해 커넥션을 유지시켜준다.

**동작 방식**
1. 트랜잭션 매니저가 데이터소스를 통해 커넥션을 만들고 트랜잭션을 시작.
2. 트랜잭션 매니저는 커넥션을 트랜잭션 동기화 매니저에 보관.
3. 리포지토리에서 동기화 매니저에 있는 커넥션을 꺼내서 사용한다.
4. 트랜잭션이 종료되면 커넥션을 커넥션 풀에 반환하거나, 커넥션을 닫는다.


#### 트랜잭션 템플릿

#### 트랜잭션 AOP
